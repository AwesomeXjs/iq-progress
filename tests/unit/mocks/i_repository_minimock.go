// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/AwesomeXjs/iq-progress/internal/repository.IRepository -o i_repository_minimock.go -n IRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/AwesomeXjs/iq-progress/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IRepositoryMock implements mm_repository.IRepository
type IRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddToBalance          func(ctx context.Context, userID int, amount int) (i1 int, err error)
	funcAddToBalanceOrigin    string
	inspectFuncAddToBalance   func(ctx context.Context, userID int, amount int)
	afterAddToBalanceCounter  uint64
	beforeAddToBalanceCounter uint64
	AddToBalanceMock          mIRepositoryMockAddToBalance

	funcAddTransaction          func(ctx context.Context, data *model.TxData, txType string) (err error)
	funcAddTransactionOrigin    string
	inspectFuncAddTransaction   func(ctx context.Context, data *model.TxData, txType string)
	afterAddTransactionCounter  uint64
	beforeAddTransactionCounter uint64
	AddTransactionMock          mIRepositoryMockAddTransaction

	funcGetOperations          func(ctx context.Context, userID int) (oa1 []model.Operation, err error)
	funcGetOperationsOrigin    string
	inspectFuncGetOperations   func(ctx context.Context, userID int)
	afterGetOperationsCounter  uint64
	beforeGetOperationsCounter uint64
	GetOperationsMock          mIRepositoryMockGetOperations

	funcRemoveFromBalance          func(ctx context.Context, userID int, amount int) (i1 int, err error)
	funcRemoveFromBalanceOrigin    string
	inspectFuncRemoveFromBalance   func(ctx context.Context, userID int, amount int)
	afterRemoveFromBalanceCounter  uint64
	beforeRemoveFromBalanceCounter uint64
	RemoveFromBalanceMock          mIRepositoryMockRemoveFromBalance
}

// NewIRepositoryMock returns a mock for mm_repository.IRepository
func NewIRepositoryMock(t minimock.Tester) *IRepositoryMock {
	m := &IRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToBalanceMock = mIRepositoryMockAddToBalance{mock: m}
	m.AddToBalanceMock.callArgs = []*IRepositoryMockAddToBalanceParams{}

	m.AddTransactionMock = mIRepositoryMockAddTransaction{mock: m}
	m.AddTransactionMock.callArgs = []*IRepositoryMockAddTransactionParams{}

	m.GetOperationsMock = mIRepositoryMockGetOperations{mock: m}
	m.GetOperationsMock.callArgs = []*IRepositoryMockGetOperationsParams{}

	m.RemoveFromBalanceMock = mIRepositoryMockRemoveFromBalance{mock: m}
	m.RemoveFromBalanceMock.callArgs = []*IRepositoryMockRemoveFromBalanceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIRepositoryMockAddToBalance struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockAddToBalanceExpectation
	expectations       []*IRepositoryMockAddToBalanceExpectation

	callArgs []*IRepositoryMockAddToBalanceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockAddToBalanceExpectation specifies expectation struct of the IRepository.AddToBalance
type IRepositoryMockAddToBalanceExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockAddToBalanceParams
	paramPtrs          *IRepositoryMockAddToBalanceParamPtrs
	expectationOrigins IRepositoryMockAddToBalanceExpectationOrigins
	results            *IRepositoryMockAddToBalanceResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockAddToBalanceParams contains parameters of the IRepository.AddToBalance
type IRepositoryMockAddToBalanceParams struct {
	ctx    context.Context
	userID int
	amount int
}

// IRepositoryMockAddToBalanceParamPtrs contains pointers to parameters of the IRepository.AddToBalance
type IRepositoryMockAddToBalanceParamPtrs struct {
	ctx    *context.Context
	userID *int
	amount *int
}

// IRepositoryMockAddToBalanceResults contains results of the IRepository.AddToBalance
type IRepositoryMockAddToBalanceResults struct {
	i1  int
	err error
}

// IRepositoryMockAddToBalanceOrigins contains origins of expectations of the IRepository.AddToBalance
type IRepositoryMockAddToBalanceExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originAmount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddToBalance *mIRepositoryMockAddToBalance) Optional() *mIRepositoryMockAddToBalance {
	mmAddToBalance.optional = true
	return mmAddToBalance
}

// Expect sets up expected params for IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) Expect(ctx context.Context, userID int, amount int) *mIRepositoryMockAddToBalance {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	if mmAddToBalance.defaultExpectation == nil {
		mmAddToBalance.defaultExpectation = &IRepositoryMockAddToBalanceExpectation{}
	}

	if mmAddToBalance.defaultExpectation.paramPtrs != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by ExpectParams functions")
	}

	mmAddToBalance.defaultExpectation.params = &IRepositoryMockAddToBalanceParams{ctx, userID, amount}
	mmAddToBalance.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddToBalance.expectations {
		if minimock.Equal(e.params, mmAddToBalance.defaultExpectation.params) {
			mmAddToBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToBalance.defaultExpectation.params)
		}
	}

	return mmAddToBalance
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockAddToBalance {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	if mmAddToBalance.defaultExpectation == nil {
		mmAddToBalance.defaultExpectation = &IRepositoryMockAddToBalanceExpectation{}
	}

	if mmAddToBalance.defaultExpectation.params != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Expect")
	}

	if mmAddToBalance.defaultExpectation.paramPtrs == nil {
		mmAddToBalance.defaultExpectation.paramPtrs = &IRepositoryMockAddToBalanceParamPtrs{}
	}
	mmAddToBalance.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddToBalance.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddToBalance
}

// ExpectUserIDParam2 sets up expected param userID for IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) ExpectUserIDParam2(userID int) *mIRepositoryMockAddToBalance {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	if mmAddToBalance.defaultExpectation == nil {
		mmAddToBalance.defaultExpectation = &IRepositoryMockAddToBalanceExpectation{}
	}

	if mmAddToBalance.defaultExpectation.params != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Expect")
	}

	if mmAddToBalance.defaultExpectation.paramPtrs == nil {
		mmAddToBalance.defaultExpectation.paramPtrs = &IRepositoryMockAddToBalanceParamPtrs{}
	}
	mmAddToBalance.defaultExpectation.paramPtrs.userID = &userID
	mmAddToBalance.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddToBalance
}

// ExpectAmountParam3 sets up expected param amount for IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) ExpectAmountParam3(amount int) *mIRepositoryMockAddToBalance {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	if mmAddToBalance.defaultExpectation == nil {
		mmAddToBalance.defaultExpectation = &IRepositoryMockAddToBalanceExpectation{}
	}

	if mmAddToBalance.defaultExpectation.params != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Expect")
	}

	if mmAddToBalance.defaultExpectation.paramPtrs == nil {
		mmAddToBalance.defaultExpectation.paramPtrs = &IRepositoryMockAddToBalanceParamPtrs{}
	}
	mmAddToBalance.defaultExpectation.paramPtrs.amount = &amount
	mmAddToBalance.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmAddToBalance
}

// Inspect accepts an inspector function that has same arguments as the IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) Inspect(f func(ctx context.Context, userID int, amount int)) *mIRepositoryMockAddToBalance {
	if mmAddToBalance.mock.inspectFuncAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.AddToBalance")
	}

	mmAddToBalance.mock.inspectFuncAddToBalance = f

	return mmAddToBalance
}

// Return sets up results that will be returned by IRepository.AddToBalance
func (mmAddToBalance *mIRepositoryMockAddToBalance) Return(i1 int, err error) *IRepositoryMock {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	if mmAddToBalance.defaultExpectation == nil {
		mmAddToBalance.defaultExpectation = &IRepositoryMockAddToBalanceExpectation{mock: mmAddToBalance.mock}
	}
	mmAddToBalance.defaultExpectation.results = &IRepositoryMockAddToBalanceResults{i1, err}
	mmAddToBalance.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddToBalance.mock
}

// Set uses given function f to mock the IRepository.AddToBalance method
func (mmAddToBalance *mIRepositoryMockAddToBalance) Set(f func(ctx context.Context, userID int, amount int) (i1 int, err error)) *IRepositoryMock {
	if mmAddToBalance.defaultExpectation != nil {
		mmAddToBalance.mock.t.Fatalf("Default expectation is already set for the IRepository.AddToBalance method")
	}

	if len(mmAddToBalance.expectations) > 0 {
		mmAddToBalance.mock.t.Fatalf("Some expectations are already set for the IRepository.AddToBalance method")
	}

	mmAddToBalance.mock.funcAddToBalance = f
	mmAddToBalance.mock.funcAddToBalanceOrigin = minimock.CallerInfo(1)
	return mmAddToBalance.mock
}

// When sets expectation for the IRepository.AddToBalance which will trigger the result defined by the following
// Then helper
func (mmAddToBalance *mIRepositoryMockAddToBalance) When(ctx context.Context, userID int, amount int) *IRepositoryMockAddToBalanceExpectation {
	if mmAddToBalance.mock.funcAddToBalance != nil {
		mmAddToBalance.mock.t.Fatalf("IRepositoryMock.AddToBalance mock is already set by Set")
	}

	expectation := &IRepositoryMockAddToBalanceExpectation{
		mock:               mmAddToBalance.mock,
		params:             &IRepositoryMockAddToBalanceParams{ctx, userID, amount},
		expectationOrigins: IRepositoryMockAddToBalanceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddToBalance.expectations = append(mmAddToBalance.expectations, expectation)
	return expectation
}

// Then sets up IRepository.AddToBalance return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockAddToBalanceExpectation) Then(i1 int, err error) *IRepositoryMock {
	e.results = &IRepositoryMockAddToBalanceResults{i1, err}
	return e.mock
}

// Times sets number of times IRepository.AddToBalance should be invoked
func (mmAddToBalance *mIRepositoryMockAddToBalance) Times(n uint64) *mIRepositoryMockAddToBalance {
	if n == 0 {
		mmAddToBalance.mock.t.Fatalf("Times of IRepositoryMock.AddToBalance mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddToBalance.expectedInvocations, n)
	mmAddToBalance.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddToBalance
}

func (mmAddToBalance *mIRepositoryMockAddToBalance) invocationsDone() bool {
	if len(mmAddToBalance.expectations) == 0 && mmAddToBalance.defaultExpectation == nil && mmAddToBalance.mock.funcAddToBalance == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddToBalance.mock.afterAddToBalanceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddToBalance.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddToBalance implements mm_repository.IRepository
func (mmAddToBalance *IRepositoryMock) AddToBalance(ctx context.Context, userID int, amount int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAddToBalance.beforeAddToBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToBalance.afterAddToBalanceCounter, 1)

	mmAddToBalance.t.Helper()

	if mmAddToBalance.inspectFuncAddToBalance != nil {
		mmAddToBalance.inspectFuncAddToBalance(ctx, userID, amount)
	}

	mm_params := IRepositoryMockAddToBalanceParams{ctx, userID, amount}

	// Record call args
	mmAddToBalance.AddToBalanceMock.mutex.Lock()
	mmAddToBalance.AddToBalanceMock.callArgs = append(mmAddToBalance.AddToBalanceMock.callArgs, &mm_params)
	mmAddToBalance.AddToBalanceMock.mutex.Unlock()

	for _, e := range mmAddToBalance.AddToBalanceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddToBalance.AddToBalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToBalance.AddToBalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToBalance.AddToBalanceMock.defaultExpectation.params
		mm_want_ptrs := mmAddToBalance.AddToBalanceMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockAddToBalanceParams{ctx, userID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddToBalance.t.Errorf("IRepositoryMock.AddToBalance got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToBalance.AddToBalanceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddToBalance.t.Errorf("IRepositoryMock.AddToBalance got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToBalance.AddToBalanceMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmAddToBalance.t.Errorf("IRepositoryMock.AddToBalance got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToBalance.AddToBalanceMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToBalance.t.Errorf("IRepositoryMock.AddToBalance got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddToBalance.AddToBalanceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToBalance.AddToBalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToBalance.t.Fatal("No results are set for the IRepositoryMock.AddToBalance")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddToBalance.funcAddToBalance != nil {
		return mmAddToBalance.funcAddToBalance(ctx, userID, amount)
	}
	mmAddToBalance.t.Fatalf("Unexpected call to IRepositoryMock.AddToBalance. %v %v %v", ctx, userID, amount)
	return
}

// AddToBalanceAfterCounter returns a count of finished IRepositoryMock.AddToBalance invocations
func (mmAddToBalance *IRepositoryMock) AddToBalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToBalance.afterAddToBalanceCounter)
}

// AddToBalanceBeforeCounter returns a count of IRepositoryMock.AddToBalance invocations
func (mmAddToBalance *IRepositoryMock) AddToBalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToBalance.beforeAddToBalanceCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.AddToBalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToBalance *mIRepositoryMockAddToBalance) Calls() []*IRepositoryMockAddToBalanceParams {
	mmAddToBalance.mutex.RLock()

	argCopy := make([]*IRepositoryMockAddToBalanceParams, len(mmAddToBalance.callArgs))
	copy(argCopy, mmAddToBalance.callArgs)

	mmAddToBalance.mutex.RUnlock()

	return argCopy
}

// MinimockAddToBalanceDone returns true if the count of the AddToBalance invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockAddToBalanceDone() bool {
	if m.AddToBalanceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddToBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddToBalanceMock.invocationsDone()
}

// MinimockAddToBalanceInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockAddToBalanceInspect() {
	for _, e := range m.AddToBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.AddToBalance at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddToBalanceCounter := mm_atomic.LoadUint64(&m.afterAddToBalanceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddToBalanceMock.defaultExpectation != nil && afterAddToBalanceCounter < 1 {
		if m.AddToBalanceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.AddToBalance at\n%s", m.AddToBalanceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.AddToBalance at\n%s with params: %#v", m.AddToBalanceMock.defaultExpectation.expectationOrigins.origin, *m.AddToBalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToBalance != nil && afterAddToBalanceCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.AddToBalance at\n%s", m.funcAddToBalanceOrigin)
	}

	if !m.AddToBalanceMock.invocationsDone() && afterAddToBalanceCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.AddToBalance at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddToBalanceMock.expectedInvocations), m.AddToBalanceMock.expectedInvocationsOrigin, afterAddToBalanceCounter)
	}
}

type mIRepositoryMockAddTransaction struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockAddTransactionExpectation
	expectations       []*IRepositoryMockAddTransactionExpectation

	callArgs []*IRepositoryMockAddTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockAddTransactionExpectation specifies expectation struct of the IRepository.AddTransaction
type IRepositoryMockAddTransactionExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockAddTransactionParams
	paramPtrs          *IRepositoryMockAddTransactionParamPtrs
	expectationOrigins IRepositoryMockAddTransactionExpectationOrigins
	results            *IRepositoryMockAddTransactionResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockAddTransactionParams contains parameters of the IRepository.AddTransaction
type IRepositoryMockAddTransactionParams struct {
	ctx    context.Context
	data   *model.TxData
	txType string
}

// IRepositoryMockAddTransactionParamPtrs contains pointers to parameters of the IRepository.AddTransaction
type IRepositoryMockAddTransactionParamPtrs struct {
	ctx    *context.Context
	data   **model.TxData
	txType *string
}

// IRepositoryMockAddTransactionResults contains results of the IRepository.AddTransaction
type IRepositoryMockAddTransactionResults struct {
	err error
}

// IRepositoryMockAddTransactionOrigins contains origins of expectations of the IRepository.AddTransaction
type IRepositoryMockAddTransactionExpectationOrigins struct {
	origin       string
	originCtx    string
	originData   string
	originTxType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddTransaction *mIRepositoryMockAddTransaction) Optional() *mIRepositoryMockAddTransaction {
	mmAddTransaction.optional = true
	return mmAddTransaction
}

// Expect sets up expected params for IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) Expect(ctx context.Context, data *model.TxData, txType string) *mIRepositoryMockAddTransaction {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	if mmAddTransaction.defaultExpectation == nil {
		mmAddTransaction.defaultExpectation = &IRepositoryMockAddTransactionExpectation{}
	}

	if mmAddTransaction.defaultExpectation.paramPtrs != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by ExpectParams functions")
	}

	mmAddTransaction.defaultExpectation.params = &IRepositoryMockAddTransactionParams{ctx, data, txType}
	mmAddTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddTransaction.expectations {
		if minimock.Equal(e.params, mmAddTransaction.defaultExpectation.params) {
			mmAddTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTransaction.defaultExpectation.params)
		}
	}

	return mmAddTransaction
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockAddTransaction {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	if mmAddTransaction.defaultExpectation == nil {
		mmAddTransaction.defaultExpectation = &IRepositoryMockAddTransactionExpectation{}
	}

	if mmAddTransaction.defaultExpectation.params != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Expect")
	}

	if mmAddTransaction.defaultExpectation.paramPtrs == nil {
		mmAddTransaction.defaultExpectation.paramPtrs = &IRepositoryMockAddTransactionParamPtrs{}
	}
	mmAddTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddTransaction
}

// ExpectDataParam2 sets up expected param data for IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) ExpectDataParam2(data *model.TxData) *mIRepositoryMockAddTransaction {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	if mmAddTransaction.defaultExpectation == nil {
		mmAddTransaction.defaultExpectation = &IRepositoryMockAddTransactionExpectation{}
	}

	if mmAddTransaction.defaultExpectation.params != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Expect")
	}

	if mmAddTransaction.defaultExpectation.paramPtrs == nil {
		mmAddTransaction.defaultExpectation.paramPtrs = &IRepositoryMockAddTransactionParamPtrs{}
	}
	mmAddTransaction.defaultExpectation.paramPtrs.data = &data
	mmAddTransaction.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmAddTransaction
}

// ExpectTxTypeParam3 sets up expected param txType for IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) ExpectTxTypeParam3(txType string) *mIRepositoryMockAddTransaction {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	if mmAddTransaction.defaultExpectation == nil {
		mmAddTransaction.defaultExpectation = &IRepositoryMockAddTransactionExpectation{}
	}

	if mmAddTransaction.defaultExpectation.params != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Expect")
	}

	if mmAddTransaction.defaultExpectation.paramPtrs == nil {
		mmAddTransaction.defaultExpectation.paramPtrs = &IRepositoryMockAddTransactionParamPtrs{}
	}
	mmAddTransaction.defaultExpectation.paramPtrs.txType = &txType
	mmAddTransaction.defaultExpectation.expectationOrigins.originTxType = minimock.CallerInfo(1)

	return mmAddTransaction
}

// Inspect accepts an inspector function that has same arguments as the IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) Inspect(f func(ctx context.Context, data *model.TxData, txType string)) *mIRepositoryMockAddTransaction {
	if mmAddTransaction.mock.inspectFuncAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.AddTransaction")
	}

	mmAddTransaction.mock.inspectFuncAddTransaction = f

	return mmAddTransaction
}

// Return sets up results that will be returned by IRepository.AddTransaction
func (mmAddTransaction *mIRepositoryMockAddTransaction) Return(err error) *IRepositoryMock {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	if mmAddTransaction.defaultExpectation == nil {
		mmAddTransaction.defaultExpectation = &IRepositoryMockAddTransactionExpectation{mock: mmAddTransaction.mock}
	}
	mmAddTransaction.defaultExpectation.results = &IRepositoryMockAddTransactionResults{err}
	mmAddTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddTransaction.mock
}

// Set uses given function f to mock the IRepository.AddTransaction method
func (mmAddTransaction *mIRepositoryMockAddTransaction) Set(f func(ctx context.Context, data *model.TxData, txType string) (err error)) *IRepositoryMock {
	if mmAddTransaction.defaultExpectation != nil {
		mmAddTransaction.mock.t.Fatalf("Default expectation is already set for the IRepository.AddTransaction method")
	}

	if len(mmAddTransaction.expectations) > 0 {
		mmAddTransaction.mock.t.Fatalf("Some expectations are already set for the IRepository.AddTransaction method")
	}

	mmAddTransaction.mock.funcAddTransaction = f
	mmAddTransaction.mock.funcAddTransactionOrigin = minimock.CallerInfo(1)
	return mmAddTransaction.mock
}

// When sets expectation for the IRepository.AddTransaction which will trigger the result defined by the following
// Then helper
func (mmAddTransaction *mIRepositoryMockAddTransaction) When(ctx context.Context, data *model.TxData, txType string) *IRepositoryMockAddTransactionExpectation {
	if mmAddTransaction.mock.funcAddTransaction != nil {
		mmAddTransaction.mock.t.Fatalf("IRepositoryMock.AddTransaction mock is already set by Set")
	}

	expectation := &IRepositoryMockAddTransactionExpectation{
		mock:               mmAddTransaction.mock,
		params:             &IRepositoryMockAddTransactionParams{ctx, data, txType},
		expectationOrigins: IRepositoryMockAddTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddTransaction.expectations = append(mmAddTransaction.expectations, expectation)
	return expectation
}

// Then sets up IRepository.AddTransaction return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockAddTransactionExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockAddTransactionResults{err}
	return e.mock
}

// Times sets number of times IRepository.AddTransaction should be invoked
func (mmAddTransaction *mIRepositoryMockAddTransaction) Times(n uint64) *mIRepositoryMockAddTransaction {
	if n == 0 {
		mmAddTransaction.mock.t.Fatalf("Times of IRepositoryMock.AddTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddTransaction.expectedInvocations, n)
	mmAddTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddTransaction
}

func (mmAddTransaction *mIRepositoryMockAddTransaction) invocationsDone() bool {
	if len(mmAddTransaction.expectations) == 0 && mmAddTransaction.defaultExpectation == nil && mmAddTransaction.mock.funcAddTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddTransaction.mock.afterAddTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddTransaction implements mm_repository.IRepository
func (mmAddTransaction *IRepositoryMock) AddTransaction(ctx context.Context, data *model.TxData, txType string) (err error) {
	mm_atomic.AddUint64(&mmAddTransaction.beforeAddTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTransaction.afterAddTransactionCounter, 1)

	mmAddTransaction.t.Helper()

	if mmAddTransaction.inspectFuncAddTransaction != nil {
		mmAddTransaction.inspectFuncAddTransaction(ctx, data, txType)
	}

	mm_params := IRepositoryMockAddTransactionParams{ctx, data, txType}

	// Record call args
	mmAddTransaction.AddTransactionMock.mutex.Lock()
	mmAddTransaction.AddTransactionMock.callArgs = append(mmAddTransaction.AddTransactionMock.callArgs, &mm_params)
	mmAddTransaction.AddTransactionMock.mutex.Unlock()

	for _, e := range mmAddTransaction.AddTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddTransaction.AddTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTransaction.AddTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTransaction.AddTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmAddTransaction.AddTransactionMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockAddTransactionParams{ctx, data, txType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddTransaction.t.Errorf("IRepositoryMock.AddTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTransaction.AddTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmAddTransaction.t.Errorf("IRepositoryMock.AddTransaction got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTransaction.AddTransactionMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

			if mm_want_ptrs.txType != nil && !minimock.Equal(*mm_want_ptrs.txType, mm_got.txType) {
				mmAddTransaction.t.Errorf("IRepositoryMock.AddTransaction got unexpected parameter txType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTransaction.AddTransactionMock.defaultExpectation.expectationOrigins.originTxType, *mm_want_ptrs.txType, mm_got.txType, minimock.Diff(*mm_want_ptrs.txType, mm_got.txType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTransaction.t.Errorf("IRepositoryMock.AddTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddTransaction.AddTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTransaction.AddTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTransaction.t.Fatal("No results are set for the IRepositoryMock.AddTransaction")
		}
		return (*mm_results).err
	}
	if mmAddTransaction.funcAddTransaction != nil {
		return mmAddTransaction.funcAddTransaction(ctx, data, txType)
	}
	mmAddTransaction.t.Fatalf("Unexpected call to IRepositoryMock.AddTransaction. %v %v %v", ctx, data, txType)
	return
}

// AddTransactionAfterCounter returns a count of finished IRepositoryMock.AddTransaction invocations
func (mmAddTransaction *IRepositoryMock) AddTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTransaction.afterAddTransactionCounter)
}

// AddTransactionBeforeCounter returns a count of IRepositoryMock.AddTransaction invocations
func (mmAddTransaction *IRepositoryMock) AddTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTransaction.beforeAddTransactionCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.AddTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTransaction *mIRepositoryMockAddTransaction) Calls() []*IRepositoryMockAddTransactionParams {
	mmAddTransaction.mutex.RLock()

	argCopy := make([]*IRepositoryMockAddTransactionParams, len(mmAddTransaction.callArgs))
	copy(argCopy, mmAddTransaction.callArgs)

	mmAddTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockAddTransactionDone returns true if the count of the AddTransaction invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockAddTransactionDone() bool {
	if m.AddTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddTransactionMock.invocationsDone()
}

// MinimockAddTransactionInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockAddTransactionInspect() {
	for _, e := range m.AddTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.AddTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddTransactionCounter := mm_atomic.LoadUint64(&m.afterAddTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddTransactionMock.defaultExpectation != nil && afterAddTransactionCounter < 1 {
		if m.AddTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.AddTransaction at\n%s", m.AddTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.AddTransaction at\n%s with params: %#v", m.AddTransactionMock.defaultExpectation.expectationOrigins.origin, *m.AddTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTransaction != nil && afterAddTransactionCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.AddTransaction at\n%s", m.funcAddTransactionOrigin)
	}

	if !m.AddTransactionMock.invocationsDone() && afterAddTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.AddTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddTransactionMock.expectedInvocations), m.AddTransactionMock.expectedInvocationsOrigin, afterAddTransactionCounter)
	}
}

type mIRepositoryMockGetOperations struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetOperationsExpectation
	expectations       []*IRepositoryMockGetOperationsExpectation

	callArgs []*IRepositoryMockGetOperationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetOperationsExpectation specifies expectation struct of the IRepository.GetOperations
type IRepositoryMockGetOperationsExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetOperationsParams
	paramPtrs          *IRepositoryMockGetOperationsParamPtrs
	expectationOrigins IRepositoryMockGetOperationsExpectationOrigins
	results            *IRepositoryMockGetOperationsResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetOperationsParams contains parameters of the IRepository.GetOperations
type IRepositoryMockGetOperationsParams struct {
	ctx    context.Context
	userID int
}

// IRepositoryMockGetOperationsParamPtrs contains pointers to parameters of the IRepository.GetOperations
type IRepositoryMockGetOperationsParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// IRepositoryMockGetOperationsResults contains results of the IRepository.GetOperations
type IRepositoryMockGetOperationsResults struct {
	oa1 []model.Operation
	err error
}

// IRepositoryMockGetOperationsOrigins contains origins of expectations of the IRepository.GetOperations
type IRepositoryMockGetOperationsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOperations *mIRepositoryMockGetOperations) Optional() *mIRepositoryMockGetOperations {
	mmGetOperations.optional = true
	return mmGetOperations
}

// Expect sets up expected params for IRepository.GetOperations
func (mmGetOperations *mIRepositoryMockGetOperations) Expect(ctx context.Context, userID int) *mIRepositoryMockGetOperations {
	if mmGetOperations.mock.funcGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Set")
	}

	if mmGetOperations.defaultExpectation == nil {
		mmGetOperations.defaultExpectation = &IRepositoryMockGetOperationsExpectation{}
	}

	if mmGetOperations.defaultExpectation.paramPtrs != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by ExpectParams functions")
	}

	mmGetOperations.defaultExpectation.params = &IRepositoryMockGetOperationsParams{ctx, userID}
	mmGetOperations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOperations.expectations {
		if minimock.Equal(e.params, mmGetOperations.defaultExpectation.params) {
			mmGetOperations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOperations.defaultExpectation.params)
		}
	}

	return mmGetOperations
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetOperations
func (mmGetOperations *mIRepositoryMockGetOperations) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetOperations {
	if mmGetOperations.mock.funcGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Set")
	}

	if mmGetOperations.defaultExpectation == nil {
		mmGetOperations.defaultExpectation = &IRepositoryMockGetOperationsExpectation{}
	}

	if mmGetOperations.defaultExpectation.params != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Expect")
	}

	if mmGetOperations.defaultExpectation.paramPtrs == nil {
		mmGetOperations.defaultExpectation.paramPtrs = &IRepositoryMockGetOperationsParamPtrs{}
	}
	mmGetOperations.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOperations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOperations
}

// ExpectUserIDParam2 sets up expected param userID for IRepository.GetOperations
func (mmGetOperations *mIRepositoryMockGetOperations) ExpectUserIDParam2(userID int) *mIRepositoryMockGetOperations {
	if mmGetOperations.mock.funcGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Set")
	}

	if mmGetOperations.defaultExpectation == nil {
		mmGetOperations.defaultExpectation = &IRepositoryMockGetOperationsExpectation{}
	}

	if mmGetOperations.defaultExpectation.params != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Expect")
	}

	if mmGetOperations.defaultExpectation.paramPtrs == nil {
		mmGetOperations.defaultExpectation.paramPtrs = &IRepositoryMockGetOperationsParamPtrs{}
	}
	mmGetOperations.defaultExpectation.paramPtrs.userID = &userID
	mmGetOperations.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOperations
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetOperations
func (mmGetOperations *mIRepositoryMockGetOperations) Inspect(f func(ctx context.Context, userID int)) *mIRepositoryMockGetOperations {
	if mmGetOperations.mock.inspectFuncGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetOperations")
	}

	mmGetOperations.mock.inspectFuncGetOperations = f

	return mmGetOperations
}

// Return sets up results that will be returned by IRepository.GetOperations
func (mmGetOperations *mIRepositoryMockGetOperations) Return(oa1 []model.Operation, err error) *IRepositoryMock {
	if mmGetOperations.mock.funcGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Set")
	}

	if mmGetOperations.defaultExpectation == nil {
		mmGetOperations.defaultExpectation = &IRepositoryMockGetOperationsExpectation{mock: mmGetOperations.mock}
	}
	mmGetOperations.defaultExpectation.results = &IRepositoryMockGetOperationsResults{oa1, err}
	mmGetOperations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOperations.mock
}

// Set uses given function f to mock the IRepository.GetOperations method
func (mmGetOperations *mIRepositoryMockGetOperations) Set(f func(ctx context.Context, userID int) (oa1 []model.Operation, err error)) *IRepositoryMock {
	if mmGetOperations.defaultExpectation != nil {
		mmGetOperations.mock.t.Fatalf("Default expectation is already set for the IRepository.GetOperations method")
	}

	if len(mmGetOperations.expectations) > 0 {
		mmGetOperations.mock.t.Fatalf("Some expectations are already set for the IRepository.GetOperations method")
	}

	mmGetOperations.mock.funcGetOperations = f
	mmGetOperations.mock.funcGetOperationsOrigin = minimock.CallerInfo(1)
	return mmGetOperations.mock
}

// When sets expectation for the IRepository.GetOperations which will trigger the result defined by the following
// Then helper
func (mmGetOperations *mIRepositoryMockGetOperations) When(ctx context.Context, userID int) *IRepositoryMockGetOperationsExpectation {
	if mmGetOperations.mock.funcGetOperations != nil {
		mmGetOperations.mock.t.Fatalf("IRepositoryMock.GetOperations mock is already set by Set")
	}

	expectation := &IRepositoryMockGetOperationsExpectation{
		mock:               mmGetOperations.mock,
		params:             &IRepositoryMockGetOperationsParams{ctx, userID},
		expectationOrigins: IRepositoryMockGetOperationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOperations.expectations = append(mmGetOperations.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetOperations return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetOperationsExpectation) Then(oa1 []model.Operation, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetOperationsResults{oa1, err}
	return e.mock
}

// Times sets number of times IRepository.GetOperations should be invoked
func (mmGetOperations *mIRepositoryMockGetOperations) Times(n uint64) *mIRepositoryMockGetOperations {
	if n == 0 {
		mmGetOperations.mock.t.Fatalf("Times of IRepositoryMock.GetOperations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOperations.expectedInvocations, n)
	mmGetOperations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOperations
}

func (mmGetOperations *mIRepositoryMockGetOperations) invocationsDone() bool {
	if len(mmGetOperations.expectations) == 0 && mmGetOperations.defaultExpectation == nil && mmGetOperations.mock.funcGetOperations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOperations.mock.afterGetOperationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOperations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOperations implements mm_repository.IRepository
func (mmGetOperations *IRepositoryMock) GetOperations(ctx context.Context, userID int) (oa1 []model.Operation, err error) {
	mm_atomic.AddUint64(&mmGetOperations.beforeGetOperationsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOperations.afterGetOperationsCounter, 1)

	mmGetOperations.t.Helper()

	if mmGetOperations.inspectFuncGetOperations != nil {
		mmGetOperations.inspectFuncGetOperations(ctx, userID)
	}

	mm_params := IRepositoryMockGetOperationsParams{ctx, userID}

	// Record call args
	mmGetOperations.GetOperationsMock.mutex.Lock()
	mmGetOperations.GetOperationsMock.callArgs = append(mmGetOperations.GetOperationsMock.callArgs, &mm_params)
	mmGetOperations.GetOperationsMock.mutex.Unlock()

	for _, e := range mmGetOperations.GetOperationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOperations.GetOperationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOperations.GetOperationsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOperations.GetOperationsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOperations.GetOperationsMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetOperationsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOperations.t.Errorf("IRepositoryMock.GetOperations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOperations.GetOperationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOperations.t.Errorf("IRepositoryMock.GetOperations got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOperations.GetOperationsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOperations.t.Errorf("IRepositoryMock.GetOperations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOperations.GetOperationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOperations.GetOperationsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOperations.t.Fatal("No results are set for the IRepositoryMock.GetOperations")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOperations.funcGetOperations != nil {
		return mmGetOperations.funcGetOperations(ctx, userID)
	}
	mmGetOperations.t.Fatalf("Unexpected call to IRepositoryMock.GetOperations. %v %v", ctx, userID)
	return
}

// GetOperationsAfterCounter returns a count of finished IRepositoryMock.GetOperations invocations
func (mmGetOperations *IRepositoryMock) GetOperationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOperations.afterGetOperationsCounter)
}

// GetOperationsBeforeCounter returns a count of IRepositoryMock.GetOperations invocations
func (mmGetOperations *IRepositoryMock) GetOperationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOperations.beforeGetOperationsCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetOperations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOperations *mIRepositoryMockGetOperations) Calls() []*IRepositoryMockGetOperationsParams {
	mmGetOperations.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetOperationsParams, len(mmGetOperations.callArgs))
	copy(argCopy, mmGetOperations.callArgs)

	mmGetOperations.mutex.RUnlock()

	return argCopy
}

// MinimockGetOperationsDone returns true if the count of the GetOperations invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetOperationsDone() bool {
	if m.GetOperationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOperationsMock.invocationsDone()
}

// MinimockGetOperationsInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetOperationsInspect() {
	for _, e := range m.GetOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetOperations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOperationsCounter := mm_atomic.LoadUint64(&m.afterGetOperationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOperationsMock.defaultExpectation != nil && afterGetOperationsCounter < 1 {
		if m.GetOperationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetOperations at\n%s", m.GetOperationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetOperations at\n%s with params: %#v", m.GetOperationsMock.defaultExpectation.expectationOrigins.origin, *m.GetOperationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOperations != nil && afterGetOperationsCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetOperations at\n%s", m.funcGetOperationsOrigin)
	}

	if !m.GetOperationsMock.invocationsDone() && afterGetOperationsCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetOperations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOperationsMock.expectedInvocations), m.GetOperationsMock.expectedInvocationsOrigin, afterGetOperationsCounter)
	}
}

type mIRepositoryMockRemoveFromBalance struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockRemoveFromBalanceExpectation
	expectations       []*IRepositoryMockRemoveFromBalanceExpectation

	callArgs []*IRepositoryMockRemoveFromBalanceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockRemoveFromBalanceExpectation specifies expectation struct of the IRepository.RemoveFromBalance
type IRepositoryMockRemoveFromBalanceExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockRemoveFromBalanceParams
	paramPtrs          *IRepositoryMockRemoveFromBalanceParamPtrs
	expectationOrigins IRepositoryMockRemoveFromBalanceExpectationOrigins
	results            *IRepositoryMockRemoveFromBalanceResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockRemoveFromBalanceParams contains parameters of the IRepository.RemoveFromBalance
type IRepositoryMockRemoveFromBalanceParams struct {
	ctx    context.Context
	userID int
	amount int
}

// IRepositoryMockRemoveFromBalanceParamPtrs contains pointers to parameters of the IRepository.RemoveFromBalance
type IRepositoryMockRemoveFromBalanceParamPtrs struct {
	ctx    *context.Context
	userID *int
	amount *int
}

// IRepositoryMockRemoveFromBalanceResults contains results of the IRepository.RemoveFromBalance
type IRepositoryMockRemoveFromBalanceResults struct {
	i1  int
	err error
}

// IRepositoryMockRemoveFromBalanceOrigins contains origins of expectations of the IRepository.RemoveFromBalance
type IRepositoryMockRemoveFromBalanceExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originAmount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Optional() *mIRepositoryMockRemoveFromBalance {
	mmRemoveFromBalance.optional = true
	return mmRemoveFromBalance
}

// Expect sets up expected params for IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Expect(ctx context.Context, userID int, amount int) *mIRepositoryMockRemoveFromBalance {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	if mmRemoveFromBalance.defaultExpectation == nil {
		mmRemoveFromBalance.defaultExpectation = &IRepositoryMockRemoveFromBalanceExpectation{}
	}

	if mmRemoveFromBalance.defaultExpectation.paramPtrs != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by ExpectParams functions")
	}

	mmRemoveFromBalance.defaultExpectation.params = &IRepositoryMockRemoveFromBalanceParams{ctx, userID, amount}
	mmRemoveFromBalance.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveFromBalance.expectations {
		if minimock.Equal(e.params, mmRemoveFromBalance.defaultExpectation.params) {
			mmRemoveFromBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveFromBalance.defaultExpectation.params)
		}
	}

	return mmRemoveFromBalance
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockRemoveFromBalance {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	if mmRemoveFromBalance.defaultExpectation == nil {
		mmRemoveFromBalance.defaultExpectation = &IRepositoryMockRemoveFromBalanceExpectation{}
	}

	if mmRemoveFromBalance.defaultExpectation.params != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Expect")
	}

	if mmRemoveFromBalance.defaultExpectation.paramPtrs == nil {
		mmRemoveFromBalance.defaultExpectation.paramPtrs = &IRepositoryMockRemoveFromBalanceParamPtrs{}
	}
	mmRemoveFromBalance.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveFromBalance.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveFromBalance
}

// ExpectUserIDParam2 sets up expected param userID for IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) ExpectUserIDParam2(userID int) *mIRepositoryMockRemoveFromBalance {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	if mmRemoveFromBalance.defaultExpectation == nil {
		mmRemoveFromBalance.defaultExpectation = &IRepositoryMockRemoveFromBalanceExpectation{}
	}

	if mmRemoveFromBalance.defaultExpectation.params != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Expect")
	}

	if mmRemoveFromBalance.defaultExpectation.paramPtrs == nil {
		mmRemoveFromBalance.defaultExpectation.paramPtrs = &IRepositoryMockRemoveFromBalanceParamPtrs{}
	}
	mmRemoveFromBalance.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveFromBalance.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveFromBalance
}

// ExpectAmountParam3 sets up expected param amount for IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) ExpectAmountParam3(amount int) *mIRepositoryMockRemoveFromBalance {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	if mmRemoveFromBalance.defaultExpectation == nil {
		mmRemoveFromBalance.defaultExpectation = &IRepositoryMockRemoveFromBalanceExpectation{}
	}

	if mmRemoveFromBalance.defaultExpectation.params != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Expect")
	}

	if mmRemoveFromBalance.defaultExpectation.paramPtrs == nil {
		mmRemoveFromBalance.defaultExpectation.paramPtrs = &IRepositoryMockRemoveFromBalanceParamPtrs{}
	}
	mmRemoveFromBalance.defaultExpectation.paramPtrs.amount = &amount
	mmRemoveFromBalance.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmRemoveFromBalance
}

// Inspect accepts an inspector function that has same arguments as the IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Inspect(f func(ctx context.Context, userID int, amount int)) *mIRepositoryMockRemoveFromBalance {
	if mmRemoveFromBalance.mock.inspectFuncRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.RemoveFromBalance")
	}

	mmRemoveFromBalance.mock.inspectFuncRemoveFromBalance = f

	return mmRemoveFromBalance
}

// Return sets up results that will be returned by IRepository.RemoveFromBalance
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Return(i1 int, err error) *IRepositoryMock {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	if mmRemoveFromBalance.defaultExpectation == nil {
		mmRemoveFromBalance.defaultExpectation = &IRepositoryMockRemoveFromBalanceExpectation{mock: mmRemoveFromBalance.mock}
	}
	mmRemoveFromBalance.defaultExpectation.results = &IRepositoryMockRemoveFromBalanceResults{i1, err}
	mmRemoveFromBalance.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveFromBalance.mock
}

// Set uses given function f to mock the IRepository.RemoveFromBalance method
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Set(f func(ctx context.Context, userID int, amount int) (i1 int, err error)) *IRepositoryMock {
	if mmRemoveFromBalance.defaultExpectation != nil {
		mmRemoveFromBalance.mock.t.Fatalf("Default expectation is already set for the IRepository.RemoveFromBalance method")
	}

	if len(mmRemoveFromBalance.expectations) > 0 {
		mmRemoveFromBalance.mock.t.Fatalf("Some expectations are already set for the IRepository.RemoveFromBalance method")
	}

	mmRemoveFromBalance.mock.funcRemoveFromBalance = f
	mmRemoveFromBalance.mock.funcRemoveFromBalanceOrigin = minimock.CallerInfo(1)
	return mmRemoveFromBalance.mock
}

// When sets expectation for the IRepository.RemoveFromBalance which will trigger the result defined by the following
// Then helper
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) When(ctx context.Context, userID int, amount int) *IRepositoryMockRemoveFromBalanceExpectation {
	if mmRemoveFromBalance.mock.funcRemoveFromBalance != nil {
		mmRemoveFromBalance.mock.t.Fatalf("IRepositoryMock.RemoveFromBalance mock is already set by Set")
	}

	expectation := &IRepositoryMockRemoveFromBalanceExpectation{
		mock:               mmRemoveFromBalance.mock,
		params:             &IRepositoryMockRemoveFromBalanceParams{ctx, userID, amount},
		expectationOrigins: IRepositoryMockRemoveFromBalanceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveFromBalance.expectations = append(mmRemoveFromBalance.expectations, expectation)
	return expectation
}

// Then sets up IRepository.RemoveFromBalance return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockRemoveFromBalanceExpectation) Then(i1 int, err error) *IRepositoryMock {
	e.results = &IRepositoryMockRemoveFromBalanceResults{i1, err}
	return e.mock
}

// Times sets number of times IRepository.RemoveFromBalance should be invoked
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Times(n uint64) *mIRepositoryMockRemoveFromBalance {
	if n == 0 {
		mmRemoveFromBalance.mock.t.Fatalf("Times of IRepositoryMock.RemoveFromBalance mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveFromBalance.expectedInvocations, n)
	mmRemoveFromBalance.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveFromBalance
}

func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) invocationsDone() bool {
	if len(mmRemoveFromBalance.expectations) == 0 && mmRemoveFromBalance.defaultExpectation == nil && mmRemoveFromBalance.mock.funcRemoveFromBalance == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveFromBalance.mock.afterRemoveFromBalanceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveFromBalance.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveFromBalance implements mm_repository.IRepository
func (mmRemoveFromBalance *IRepositoryMock) RemoveFromBalance(ctx context.Context, userID int, amount int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmRemoveFromBalance.beforeRemoveFromBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveFromBalance.afterRemoveFromBalanceCounter, 1)

	mmRemoveFromBalance.t.Helper()

	if mmRemoveFromBalance.inspectFuncRemoveFromBalance != nil {
		mmRemoveFromBalance.inspectFuncRemoveFromBalance(ctx, userID, amount)
	}

	mm_params := IRepositoryMockRemoveFromBalanceParams{ctx, userID, amount}

	// Record call args
	mmRemoveFromBalance.RemoveFromBalanceMock.mutex.Lock()
	mmRemoveFromBalance.RemoveFromBalanceMock.callArgs = append(mmRemoveFromBalance.RemoveFromBalanceMock.callArgs, &mm_params)
	mmRemoveFromBalance.RemoveFromBalanceMock.mutex.Unlock()

	for _, e := range mmRemoveFromBalance.RemoveFromBalanceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockRemoveFromBalanceParams{ctx, userID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveFromBalance.t.Errorf("IRepositoryMock.RemoveFromBalance got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveFromBalance.t.Errorf("IRepositoryMock.RemoveFromBalance got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmRemoveFromBalance.t.Errorf("IRepositoryMock.RemoveFromBalance got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveFromBalance.t.Errorf("IRepositoryMock.RemoveFromBalance got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveFromBalance.RemoveFromBalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveFromBalance.t.Fatal("No results are set for the IRepositoryMock.RemoveFromBalance")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmRemoveFromBalance.funcRemoveFromBalance != nil {
		return mmRemoveFromBalance.funcRemoveFromBalance(ctx, userID, amount)
	}
	mmRemoveFromBalance.t.Fatalf("Unexpected call to IRepositoryMock.RemoveFromBalance. %v %v %v", ctx, userID, amount)
	return
}

// RemoveFromBalanceAfterCounter returns a count of finished IRepositoryMock.RemoveFromBalance invocations
func (mmRemoveFromBalance *IRepositoryMock) RemoveFromBalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromBalance.afterRemoveFromBalanceCounter)
}

// RemoveFromBalanceBeforeCounter returns a count of IRepositoryMock.RemoveFromBalance invocations
func (mmRemoveFromBalance *IRepositoryMock) RemoveFromBalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromBalance.beforeRemoveFromBalanceCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.RemoveFromBalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveFromBalance *mIRepositoryMockRemoveFromBalance) Calls() []*IRepositoryMockRemoveFromBalanceParams {
	mmRemoveFromBalance.mutex.RLock()

	argCopy := make([]*IRepositoryMockRemoveFromBalanceParams, len(mmRemoveFromBalance.callArgs))
	copy(argCopy, mmRemoveFromBalance.callArgs)

	mmRemoveFromBalance.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveFromBalanceDone returns true if the count of the RemoveFromBalance invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockRemoveFromBalanceDone() bool {
	if m.RemoveFromBalanceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveFromBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveFromBalanceMock.invocationsDone()
}

// MinimockRemoveFromBalanceInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockRemoveFromBalanceInspect() {
	for _, e := range m.RemoveFromBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.RemoveFromBalance at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveFromBalanceCounter := mm_atomic.LoadUint64(&m.afterRemoveFromBalanceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFromBalanceMock.defaultExpectation != nil && afterRemoveFromBalanceCounter < 1 {
		if m.RemoveFromBalanceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.RemoveFromBalance at\n%s", m.RemoveFromBalanceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.RemoveFromBalance at\n%s with params: %#v", m.RemoveFromBalanceMock.defaultExpectation.expectationOrigins.origin, *m.RemoveFromBalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFromBalance != nil && afterRemoveFromBalanceCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.RemoveFromBalance at\n%s", m.funcRemoveFromBalanceOrigin)
	}

	if !m.RemoveFromBalanceMock.invocationsDone() && afterRemoveFromBalanceCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.RemoveFromBalance at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveFromBalanceMock.expectedInvocations), m.RemoveFromBalanceMock.expectedInvocationsOrigin, afterRemoveFromBalanceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddToBalanceInspect()

			m.MinimockAddTransactionInspect()

			m.MinimockGetOperationsInspect()

			m.MinimockRemoveFromBalanceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToBalanceDone() &&
		m.MinimockAddTransactionDone() &&
		m.MinimockGetOperationsDone() &&
		m.MinimockRemoveFromBalanceDone()
}
